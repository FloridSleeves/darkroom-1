---
layout: post
title: Try Darkroom
---
<link rel="stylesheet" href="stylesheets/codemirror.css">
<script src="javascripts/codemirror.js"></script>
<script src="javascripts/lua.js"></script>
<script src="javascripts/md5.js"></script>
<h1 id='installing_terra'>Try Darkroom</h1>
<div class="example" id="blurx.t" >
import "darkroom"
darkroomSimple = terralib.require("darkroomSimple")

a = darkroomSimple.load("color.bmp")
im a(x,y) [float[3]]( a(x,y) ) end

im blurx(x,y) 
  map i=-5,5 reduce(sum) a(x+i,y)/11 end
end

im blurx(x,y) [uint8[3]]( blurx ) end -- convert to 24 bit
blurx:save(arg[1]) -- write to arg[1] to display
</div>

<div class="example" id="bruteof.t">
import "darkroom"
darkroomSimple = terralib.require "darkroomSimple"

-- brute force optical flow

searchWindowRadius = 2
SADWindowRadius = 2

local frame1 = darkroomSimple.load("frame10.bmp")
frame1 = im(x,y) [int](frame1) end
local frame2 = darkroomSimple.load("frame11.bmp")
frame2 = im(x,y) [int](frame2) end

im bruteofVectorField(x,y)
  map i=-searchWindowRadius, searchWindowRadius j=-searchWindowRadius, searchWindowRadius reduce(argmin)
    -- sum of absolute differences (SAD)
    map ii=-SADWindowRadius, SADWindowRadius jj=-SADWindowRadius, SADWindowRadius reduce(sum)
      darkroom.abs(frame1(x+ii,y+jj)-frame2(x+i+ii,y+j+jj))
    end
  end
end

-- convert this to an RGB image so that the user can view it
im ofRGB(x,y) [uint8[3]]({(bruteofVectorField(x,y)[0])*50+128, (bruteofVectorField(x,y)[1])*50+128, 0}) end
ofRGB:save(arg[1])
</div>

<div class="example" id="lucaskanade.t">
import "darkroom"
darkroomSimple = terralib.require("darkroomSimple")
terralib.require "bilinear"

windowRadius = 2
iterations = 1 -- iterations per level                                                                                                                                                  
maxResampleX = 10
maxResampleY = 10
clamp = true

function invert2x2( matrix )
  local im denom(x,y) matrix[0]*matrix[3]-matrix[1]*matrix[2] end
  local im det(x,y) if denom(x,y)~=0 then 1/denom(x,y) else 0 end end
  return im(x,y) {det*matrix[3], -det*matrix[1], -det*matrix[2], det*matrix[0]} end
end

-- see here for ref: http://www.cs.ucf.edu/~mikel/Research/Optical_Flow.htm                                                                                                             
function makeLK(frame1, frame2)
  -- calculate stuff that we will use every iteration                                                                                                                                   
  -- such as derivatives, matrix A^-1 of image gradients, weights.                                                                                                                      
  -- were calling frame1 F and frame2 G, as in the original LK paper                                                                                                                    

  -- calculate derivatives                                                                                                                                                              
  local im Fdx(x,y) (frame1(x+1,y)-frame1(x-1,y))/2 end
  local im Fdy(x,y) (frame1(x,y+1)-frame1(x,y-1))/2 end

  local im Gdx(x,y) (frame2(x+1,y)-frame2(x-1,y))/2 end
  local im Gdy(x,y) (frame2(x,y+1)-frame2(x,y-1))/2 end

  -- calculate A^-1                                                                                                                                                                     
  local im A(x,y)
    map wx = -windowRadius, windowRadius wy = -windowRadius, windowRadius reduce(sum)
    {Fdx(x+wx,y+wy)*Fdx(x+wx,y+wy), Fdx(x+wx,y+wy)*Fdy(x+wx,y+wy), Fdx(x+wx,y+wy)*Fdy(x+wx,y+wy), Fdy(x+wx,y+wy)*Fdy(x+wx,y+wy)}
    end
  end

  local Ainv = invert2x2(A)

  -- initial condition: no offset                                                                                                                                                       
  local im vectorField(x,y) [float[2]]({0,0}) end

  -- do LK calculation                                                                                                                                                                  
  for i=1,iterations do
    local G = im(x,y) [resampleBilinear( clamp, frame2, maxResampleX, maxResampleY, im(x,y) vectorField[0] end, im(x,y) vectorField[1] end)] end

    im vectorField(x,y)
      -- loop over search window                                                                                                                                                        
      b = map  wx = -windowRadius, windowRadius wy = -windowRadius, windowRadius reduce(sum)
            F = frame1 (x+wx, y+wy)
            in
            {Fdx(x+wx, y+wy)*(G(x+wx,y+wy)-F),Fdy(x+wx, y+wy)*(G(x+wx,y+wy)-F)}
          end
      in
        {Ainv[0](x,y)*(-b[0])+Ainv[1](x,y)*(-b[1])+vectorField[0],
         Ainv[2](x,y)*(-b[0])+Ainv[3](x,y)*(-b[1])+vectorField[1]}
    end
  end

  return im(x,y) [uint8[3]]({(vectorField(x,y)[0])*50+128, (vectorField(x,y)[1])*50+128, 0}) end
end

local frame1 = darkroomSimple.load("frame10.bmp")
im frame1(x,y) [float](frame1) end
local frame2 = darkroomSimple.load("frame11.bmp")
im frame2(x,y) [float](frame2) end

makeLK( frame1, frame2 ):save(arg[1])
</div>

<div class="example" id="deconv-simple.t">
import "darkroom"
darkroomSimple = terralib.require("darkroomSimple")

fusedIter = 5

function tofloat(input)
  return im(x,y) [float[3]](input(x,y)/([float](255))) end
end

function tobyte(input)
  return im(x,y) darkroom.vectorSelect( input>1, [uint8[3]](255), [uint8[3]](input*255) ) end
end

function convolve( K, input )
    local N2 = math.floor(math.sqrt(#K))
    assert(N2 % 2 == 1 and N2*N2 == #K)
    local N = math.floor(N2/2)

    return im(x,y)
      darkroom.crop(
        map i=-N,N j=-N,N reduce(sum)
          input(x+i, y+j) * K[(-j + N)*N2 + (i + N)]
        end)
    end
end

local function deconv( K, Khat, observed, latent_est, N)
  for i = 1,N do
    local est_conv = convolve(K,latent_est)
    local relative_blur = im(x,y) darkroom.crop(observed(x,y) / est_conv(x,y)) end
    local error_est = convolve(Khat,relative_blur)
    latent_est = im(x,y) darkroom.crop(latent_est(x,y)*error_est(x,y)) end
  end
  return tobyte(latent_est)
end

local K = {0.33333,0,0,
           0,0.33333,0,
           0,0,0.33333}

local observed = tofloat(darkroomSimple.load("deconvolution_blurred.bmp"))
local latent_est = im(x,y) [float[3]](0.5) end -- default value                                                                                                                         
local convoutput = deconv( K, K, observed, latent_est, fusedIter )
convoutput:save("out/deconv-simple.bmp")
</div>









<div style="float:right;">
<select id="examples" onchange="updatecontent()">
</select>
</div>
<br/>
<div id="editor">
</div>
<script>
var codemirror = CodeMirror(document.getElementById("editor"), {
  value: "",
  lineNumbers: true,
  lineWrapping: false,
  smartIndent: false,
  tabSize: 2,
  mode:  "lua"
});
function updatecontent() {
	var o = document.getElementById("examples")
	var name = o.options[o.selectedIndex].value
	var content = document.getElementById(name).textContent
	codemirror.setValue(content.replace(/^\n/,""))
	codemirror.setCursor(codemirror.lineCount(),0)
	codemirror.focus()
}
function finishresult(data) {
	var r = document.getElementById("result")
	var code = document.createElement("code")
	code.textContent = atob(data)
	var pre = document.createElement("pre")
	pre.appendChild(code)
	r.innerHTML = ""
	r.appendChild(pre)

//	var code = document.createElement("code")
//	code.textContent = md5(codemirror.getValue())
//  r.appendChild(code)

	var i = document.createElement("img")
  i.setAttribute('src', "http://candela.stanford.edu:4002/" + md5(codemirror.getValue()) + '.bmp');
	r.appendChild(i)
}
function execute() {
	var script = document.createElement("script")
	script.type = "text/javascript"
	var data = btoa(codemirror.getValue())
	script.src = "http://candela.stanford.edu:4002/" + data 
	document.getElementById("result").appendChild(script)
}
var selector = document.getElementById("examples")
var examples = document.getElementsByClassName("example")
for (var i = 0; i < examples.length; i++) {
	var o = document.createElement("option")
	o.textContent = examples[i].id
	selector.appendChild(o)
}
updatecontent()
</script>
<br>
<button type="button" style="float:right;" onclick="execute()">Execute</button>
<br>
<br>
<hr>
<div id="result"></div>
