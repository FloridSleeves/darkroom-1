<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Terra API Reference</title>
    
    <link rel="stylesheet" href="stylesheets/styles.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link rel="stylesheet" href="stylesheets/prism.css" />
  </head>
  <body>
    <div class="wrapper">
      <header>
        <a href="index.html"><h1 class="title"><img width="70px" src="logo.png">Terra</h1></a>
        <p>A low-level counterpart to Lua</p>
        <ul>
          <li><a href="https://github.com/zdevito/terra/tarball/master">Download <strong>TAR Ball</strong></a></li><li><a href="http://github.com/zdevito/terra">View On <strong>GitHub</strong></a></li>
        </ul>
        <p><a href="demo.html">Try Terra Online</a></p>
        <p><a href="getting-started.html" >Getting Started</a></p>
        <p><a href="api.html" >API Reference</a></p>
        <p><a href="publications.html">Publications</a></p>
        <p><a href="list.html">Mailing List</a></p>
        <!-- <p><a href="about.html" >About Us</a></p> -->
      </header>
      <footer>
      <p><a href="https://github.com/zdevito">Zach DeVito</a> <br>zdevito at stanford dot edu</p>
      <p><small>Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
      <section class="language-terra">
      <h1>Terra API Reference</h1>

<ul id="markdown-toc">
  <li><a href="#c-api">C API</a></li>
  <li><a href="#lua-api">Lua API</a>    <ul>
      <li><a href="#list">List</a></li>
      <li><a href="#function">Function</a></li>
      <li><a href="#function-definition">Function Definition</a></li>
      <li><a href="#constant">Constant</a></li>
      <li><a href="#global-variable">Global Variable</a></li>
      <li><a href="#macro">Macro</a></li>
      <li><a href="#escapes">Escapes</a></li>
      <li><a href="#quote">Quote</a></li>
      <li><a href="#symbol">Symbol</a></li>
      <li><a href="#types">Types</a></li>
      <li><a href="#exotypes-structs">Exotypes (Structs)</a>        <ul>
          <li><a href="#lua-api-1">Lua API</a></li>
          <li><a href="#syntax-sugar">Syntax Sugar</a></li>
        </ul>
      </li>
      <li><a href="#c-backwards-compatibility">C Backwards Compatibility</a></li>
      <li><a href="#managing-terra-values-from-lua">Managing Terra Values from Lua</a></li>
      <li><a href="#loading-terra-code">Loading Terra Code</a></li>
      <li><a href="#saving-terra-code">Saving Terra Code</a></li>
      <li><a href="#converting-between-lua-values-and-terra-values">Converting between Lua values and Terra values</a>        <ul>
          <li><a href="#converting-lua-values-to-terra-values-of-known-type">Converting Lua values to Terra values of known type</a></li>
          <li><a href="#converting-lua-values-to-terra-values-with-unknown-type">Converting Lua values to Terra values with unknown type</a></li>
          <li><a href="#compile-time-conversions">Compile-time conversions</a></li>
          <li><a href="#converting-terra-values-to-lua-values">Converting Terra values to Lua values</a></li>
        </ul>
      </li>
      <li><a href="#asynchronous-compilation">Asynchronous Compilation</a></li>
      <li><a href="#debugging">Debugging</a></li>
    </ul>
  </li>
  <li><a href="#embedded-language-api">Embedded Language API</a>    <ul>
      <li><a href="#a-simple-example">A Simple Example</a></li>
      <li><a href="#loading-and-running-the-language">Loading and Running the Language</a></li>
      <li><a href="#interacting-with-lua-symbols">Interacting with Lua symbols</a></li>
      <li><a href="#recursively-parsing-lua">Recursively Parsing Lua</a></li>
      <li><a href="#extending-statements">Extending Statements</a></li>
      <li><a href="#higher-level-parsing-via-pratt-parsers">Higher-Level Parsing via Pratt Parsers</a></li>
      <li><a href="#the-language-and-lexer-api">The Language and Lexer API</a>        <ul>
          <li><a href="#language-table">Language Table</a></li>
          <li><a href="#tokens">Tokens</a></li>
          <li><a href="#lexer">Lexer</a></li>
        </ul>
      </li>
      <li><a href="#future-extensions">Future Extensions</a></li>
    </ul>
  </li>
</ul>

<h1 id="c-api">C API</h1>

<p>Like Lua, Terra is designed to be embedded into existing code.
The C API for Terra serves as the entry-point for running Terra-Lua programs.
In fact, the <code>terra</code> executable and REPL are just clients of the C API. The Terra C API extends <a href="http://www.lua.org/manual/5.1/manual.html#3">Lua’s API</a> with a set of Terra-specific functions. A client first creates a <code>lua_State</code> object and then calls <code>terra_init</code> on it to initialize the Terra extensions. Terra provides equivalents to the <code>lua_load</code> set of functions (e.g. <code>terra_loadfile</code>), which treat the input as Terra-Lua code.</p>

<hr />
<pre><code>int terra_init(lua_State * L);
</code></pre>

<p>Initializes the internal Terra state for the <code>lua_State</code> <code>L</code>. <code>L</code> must be an already initialized <code>lua_State</code>.</p>

<hr />

<pre><code>typedef struct { /* default values are 0 */
    int verbose; /* Sets verbosity of debugging output. 
                    Valid values are 0 (no debug output) 
                    to 2 (very verbose). */
    int debug;   /* Turns on debug information in Terra compiler. 
                    Enables base pointers and line number
                    information in stack traces. */
} terra_Options;
int terra_initwithoptions(lua_State * L, terra_Options * options);
</code></pre>

<p>Initializes the internal Terra state for the <code>lua_State</code> <code>L</code>. <code>L</code> must be an already initialized <code>lua_State</code>. <code>terra_Options</code> holds additional configuration options.</p>

<hr />

<pre><code>int terra_load(lua_State *L,
               lua_Reader reader,
               void *data,
               const char *chunkname);
</code></pre>

<p>Loads a combined Terra-Lua chunk. Terra equivalent of <code>lua_load</code>. This function takes the same arguments as <code>lua_load</code> and performs identically except it parses the input as a combined Terra-Lua program (i.e. a Lua program that has Terra extensions). Currently there is no binary format for combined Lua-Terra code, so the input must be text.</p>

<hr />

<pre><code>int terra_loadfile(lua_State * L, const char * file);
</code></pre>

<p>Loads the file as a combined Terra-Lua chunk. Terra equivalent of <code>luaL_loadfile</code>.</p>

<hr />

<pre><code>int terra_loadbuffer(lua_State * L, 
                     const char *buf, 
                     size_t size, 
                     const char *name);
</code></pre>

<p>Loads a buffer as a combined Terra-Lua chunk. Terra equivalent of <code>luaL_loadbuffer</code>.</p>

<hr />

<pre><code>int terra_loadstring(lua_State *L, const char *s);
</code></pre>

<p>Loads string <code>s</code> as a combined Terra-Lua chunk. Terra equivalent of <code>luaL_loadstring</code>.</p>

<hr />

<pre><code>terra_dofile(L, file)
</code></pre>

<p>Loads and runs the file <code>file</code>. Equivalent to</p>

<pre><code>(terra_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))
</code></pre>

<hr />

<pre><code>terra_dostring(L, s)
</code></pre>

<p>Loads and runs the string <code>s</code>. Equivalent to</p>

<pre><code>(terra_loadstring(L, s) || lua_pcall(L, 0, LUA_MULTRET, 0))
</code></pre>

<h1 id="lua-api">Lua API</h1>

<p>Terra provides syntax extensions for creating Terra functions, types, and quotations.
Each of these extensions constructs a first-class Lua value. Terra’s Lua API is used to manipulate these objects. For instance, you can disassemble a function (<code>terrafn:disas()</code>), or query properties of a type (<code>typ:isarithmetic()</code>).</p>

<h2 id="list">List</h2>

<p>Lists are a simple wrapper around Lua tables that provides some additional functionality.
They are returned from other API calls (e.g. <code>func:getdefinitions()</code>)</p>

<hr />

<pre><code>terralib.newlist([lst])
</code></pre>

<p>Creates a new list. <code>lst</code> is an optional table to use as the initializer.</p>

<hr />

<pre><code>terralib.islist(exp)
</code></pre>

<p>True if <code>exp</code> is a list.</p>

<hr />

<pre><code>list:map(fn)
</code></pre>

<p>Standard list map function. <code>fn</code> is a Lua function that takes an element of the list and returns another object. </p>

<hr />

<pre><code>list:flatmap(fn)
</code></pre>

<p>The value <code>fn</code> should be a function that takes an element of the list and then returns a <em>list</em> of elements. Creates a new list by calling <code>fn</code> on each element and concatenating the results.</p>

<hr />

<pre><code>terralib.israwlist(l)
</code></pre>

<p>Returns true if <code>l</code> is a table that has no keys or has a contiguous range of integer keys from <code>1</code> to <code>N</code> for some <code>N</code>, and contains no other keys.</p>

<h2 id="function">Function</h2>

<p>Terra functions are entry-points into Terra code. Each function can contain 0 or more <a href="#function_definition">Function Definitions</a>. A function with 0 definitions is the equivalent of a function declaration in other statically typed languages. One definition indicates a simple function, and multiple definitions is the equivalent of an <a href="http://en.wikipedia.org/wiki/Function_overloading">overloaded function</a>.</p>

<hr />

<pre><code>[local] terra myfunctionname
</code></pre>

<p><em>Terra function declaration</em>. If <code>myfunctionname</code> is not already a Terra function, it creates a new function with 0 definitions and stores it the Lua variable <code>myfunctionname</code>. If <code>myfunctionname</code> is already a function, then it does not modify it.
If the optional <code>local</code> keyword is used, then <code>myfunctionname</code> is first defined as a new local Lua variable.  When used without the <code>local</code> keyword, <code>myfunctionname</code> can be a table specifier (e.g. <code>a.b.c</code>). If <code>mystruct</code> is a <a href="#exotypes_structs">Struct</a>, then <code>mystruct:mymethod</code> is equivalent to using the specifier <code>mystruct.methods.mymethod</code>.</p>

<hr />

<pre><code>[local] terra myfunctionname(arg0 : type0, 
                             ... 
                             argN : typeN) 
        [...] 
end 
</code></pre>

<p><em>Terra function definition</em>. Adds the <a href="#function_definition">function definition</a> specified by the code to the Terra function <code>myfunctionname</code>. If <code>myfunctionname</code> is not a Terra function, then it first creates a new function declaration using the same rules as Terra function declarations.  </p>

<hr />

<pre><code>myfunction(arg0,...,argN)
</code></pre>

<p><code>myfunction</code> is a Terra function. Invokes <code>myfunction</code> from Lua. It is an error to call this on a function with 0 definitions.  This utility method calls <code>funcdefinition(arg0,...argN)</code> on each of this functions definitions until it finds one that does not produce an error. For functions with a single definition this is equivalent to calling the the function definition directly. See the documentation for calling <a href="#function_definition">function definitions</a> for more details.</p>

<hr />

<pre><code>func:compile(async)
</code></pre>

<p>Utility method that calls <code>funcdefinition:compile(async)</code> on each definition of this function. See the documentation for <a href="#function_definition">function definitions</a> for more details about compilation. Can be called <a href="#asynchronous_compilation">asynchronously</a>.</p>

<hr />

<pre><code>func:emitllvm(async)
</code></pre>

<p>Utility method that calls <code>funcdefinition:emitllvm(async)</code> on each definition of this function. See the documentation for <a href="#function_definition">function definitions</a> for more details about compilation. Can be called <a href="#asynchronous_compilation">asynchronously</a>.</p>

<hr />

<pre><code>func:adddefinition(v)
</code></pre>

<p>Adds a new function definition <code>v</code> to this function.</p>

<hr />

<pre><code>func:getdefinitions()
</code></pre>

<p>Returns a <a href="#lists">List</a> of definitions for this function.</p>

<hr />

<pre><code>func:printstats()
</code></pre>

<p>Prints statistics about how long this function took to compile and JIT. Will cause the function definitions to compile.</p>

<hr />

<pre><code>func:disas()
</code></pre>

<p>Disassembles all of the function definitions into x86 assembly and optimized LLVM, and prints them out. Useful for debugging performance. Will cause the function definitions to compile.</p>

<hr />

<pre><code>func:printpretty([printcompiled])
</code></pre>

<p>Print out a visual representation of the code in this function. If <code>printcompiled</code> is <code>false</code>, then this will print out an untyped version of the function. Otherwise, this will cause the function
definitions to compile, and print out a type-checked representation of the function (with all macros and method invocations expanded).</p>

<hr />

<pre><code>terralib.isfunction(obj)
</code></pre>

<p>True if <code>obj</code> is a Terra function.</p>

<h2 id="function-definition">Function Definition</h2>

<p>Function definitions are concrete implementations of a function. Each definition is compiled lazily. A function definition may be (1) uncompiled, (2) in the process of type-checking, (3) emitted to LLVM but not JITed to machine code, or (4) JITed to machine code. Functions will only be in state (2) during calls to the Terra compiler, but may still be observable to user-defined functions like macros and metamethods that run during type-checking.</p>

<hr />

<pre><code>function terralib.isfunctiondefinition(obj)
</code></pre>

<p>True if <code>obj</code> is a function definition.</p>

<hr />

<pre><code>r0, ..., rn = myfuncdefinition(arg0, ... argN)
</code></pre>

<p>Invokes <code>myfunctiondefinition</code> from Lua. Arguments are converted into the expected Terra types using the <a href="#converting_between_lua_values_and_terra_values">rules</a> for converting between Terra values and Lua values. Return values are converted back into Lua values using the same rules. Causes the function to be compiled to machine code.</p>

<hr />

<pre><code>success, typ = funcdefinition:peektype()
</code></pre>

<p>Attempt to find out the type of this definition but do <em>not</em> compile it. If <code>success</code> is <code>true</code> then <code>typ</code> is the <a href="#types">type</a> of the function. Otherwise, the function did not have an explicitly annotated return type and was not already compiled. </p>

<hr />

<pre><code>funcdefinition:compile(async)
</code></pre>

<p>Compile the function into machine code. Can be called <a href="#asynchronous_compilation">asynchronously</a>.</p>

<hr />

<pre><code>funcdefinition:emitllvm(async)
</code></pre>

<p>Compile the function into LLVM but do not JIT to machine code. Can be called <a href="#asynchronous_compilation">asynchronously</a>. This is used for offline compilation where the machine code is not needed.</p>

<hr />

<pre><code>typ = funcdefinition:gettype(async)
</code></pre>

<p>Return the <a href="#types">type</a> of the function. This will cause the function to be emitted to LLVM. Can be called <a href="#asynchronous_compilation">asynchronously</a>.</p>

<hr />

<pre><code>funcdefinition:getpointer()
</code></pre>

<p>Return the LuaJIT <code>ctype</code> object that points to the machine code for this function. Will cause the function to be compiled.</p>

<h2 id="constant">Constant</h2>

<p>Terra constants represent constant values used in Terra code. For instance, if you want to create a <a href="http://en.wikipedia.org/wiki/Lookup_table">lookup table</a> for the <code>sin</code> function, you might first use Lua to calculate the values and then create a constant Terra array of floating point numbers to hold the values. Since the compiler knows the array is constant (as opposed to a global variable), it can make more aggressive optimizations.</p>

<hr />

<pre><code>constant([type],init)
</code></pre>

<p>Create a new constant. <code>init</code> is converted to a Terra value using the normal conversion <a href="#converting_between_lua_values_and_terra_values">rules</a>. If the optional <a href="#types">type</a> is specified, then <code>init</code> is converted to that <code>type</code> explicitly. <a href="#types">Completes</a> the type.</p>

<hr />

<pre><code>terralib.isconstant(obj)
</code></pre>

<p>True if <code>obj</code> is a Terra constant.</p>

<h2 id="global-variable">Global Variable</h2>

<p>Global variables are Terra values that are shared among all Terra functions. </p>

<hr />

<pre><code>global([type], [init])
</code></pre>

<p>Creates a new global variable of type <code>type</code> given the initial value <code>init</code>. Either <code>type</code> or <code>init</code> must be specified. If <code>type</code> is not specified we attempt to infer it from <code>init</code>. If <code>init</code> is not specified the global is left uninitialized. <code>init</code> is converted to a Terra value using the normal conversion <a href="#converting_between_lua_values_and_terra_values">rules</a>. If <code>init</code> is specified, this <a href="#types">completes</a> the type.</p>

<hr />

<pre><code>globalvar:getpointer()
</code></pre>

<p>Returns the <code>ctype</code> object that is the pointer to this global variable in memory. <a href="#types">Completes</a> the type.</p>

<hr />

<pre><code>globalvar:get()
</code></pre>

<p>Gets the value of this global as a LuaJIT <code>ctype</code> object. <a href="#types">Completes</a> the type.</p>

<hr />

<pre><code>globalvar:set(v)
</code></pre>

<p>Converts <code>v</code> to a Terra values using the normal conversion <a href="#converting_between_lua_values_and_terra_values">rules</a>, and the global variable to this value. <a href="#types">Completes</a> the type.</p>

<h2 id="macro">Macro</h2>

<p>Macros allow you to insert custom behavior into the compiler during type-checking. Because they run during compilation, they should be aware of <a href="#asynchronous_compilation">asynchronous compilation</a> when calling back into the compiler.</p>

<hr />

<pre><code>macro(function(arg0,arg1,...,argN) [...] end)
</code></pre>

<p>Create a new macro. The function will be invoked at compile time for each call in Terra code.  Each argument will be a Terra <a href="#quote">quote</a> representing the argument. For instance, the call <code>mymacro(a,b,foo())</code>), will result in three quotes as arguments to the macro.  The macro must return a single value that will be converted to a Terra object using the compilation-time conversion <a href="#converting_between_lua_values_and_terra_values">rules</a>.</p>

<hr />

<pre><code>terralib.ismacro(t)
</code></pre>

<p>True if <code>t</code> is a macro.</p>

<h2 id="escapes">Escapes</h2>

<p>Escapes are a special construct adapted from <a href="http://www.cs.rice.edu/~taha/MSP/">multi-stage programming</a> that allow you to use Lua to generate Terra expressions. Escapes are created using the bracket operator and contain a single lua expression (e.g. <code>[ 4 + 5 ]</code>) that is evaluated when the surrounding Terra code is <em>defined</em> (note: this is different from <a href="#macros">macros</a> which run when a function is <em>compiled</em>). Escapes are evaluated in the lexical scope of the Terra code. In addition to including the identifiers in the surround Lua scope, this scope will include any identifiers defined in the Terra code. In Lua code these identifiers are represented as <a href="#symbol">symbols</a>. For example, in the following escape:</p>

<pre><code>terra foo(a : int)
    var b = 4
    return [dosomething(a,b)]
end
</code></pre>

<p>The arguments <code>a</code> and <code>b</code> to <code>dosomething</code> will be <a href="#symbols">symbols</a> that are references to the variables defined in the Terra code. </p>

<p>We also provide syntax sugar for escapes of identifiers and table selects when they are used in expressions or statements. For instance the Terra expression <code>ident</code> is treated as the escape <code>[ident]</code>, and the table selection <code>a.b.c</code> is treated as the escape <code>[a.b.c]</code> when both <code>a</code> and <code>b</code> are Lua tables.</p>

<hr />

<pre><code>terra foo()
    return [luaexpr],4
end 
</code></pre>

<p><code>[luaexpr]</code> is a single-expression escape. <code>luaexpr</code> is a single Lua expression that is evaluated to a Lua value when the function is <em>defined</em>. The resulting Lua expression is converted to a Terra object using the compilation-time conversion <a href="#converting_between_lua_values_and_terra_values">rules</a>. If the conversion results in a list of Terra values, it is truncated to a single value.</p>

<hr />
<pre><code>terra foo()
    bar(3,4,[luaexpr])
end
</code></pre>

<p><code>[luaexpr]</code> is a multiple-expression escape since it occurs as the last expression in a list of expressions. It has the same behavior as a single expression escape, except when the conversion of <code>luaexpr</code> results in multiple Terra expressions. In this case, the values are appended to the end of the expression list (in this case, the list of arguments to the call to <code>bar</code>).</p>

<hr />

<pre><code>terra foo()
    [luaexpr]
    return 4
end
</code></pre>

<p><code>[luaexpr]</code> is a statement escape. This form has the same behavior as a multiple-expression escape but is also allowed to return <a href="#quote">quotes</a> of Terra statements. If the conversion from <code>luaexpr</code> results in a list of Terra values, then are all inserted into the current block.</p>

<hr />

<pre><code>terra foo([luaexpr] : int)
    var [luaexpr] = 4
    mystruct.[luaexpr]
end
</code></pre>

<p>Each <code>[luaexpr]</code> is an example of a escape of an identifier. <code>luaexpr</code> must result in a <a href="#symbol">symbol</a>. For field selectors (<code>a.[luaexpr]</code>), methods (<code>a:[luaexpr]()</code>) or labels (<code>goto [luaexpr]</code>), <code>luaexpr</code> can also result in a string. This form allows you to define identifiers programmatically. When a symbol with an explicitly defined type is used to define a variable, then the variable will take the type of the symbol unless the type of the variable is explicitly specified. For instance if we construct a symbol (<code>foo = symbol(int)</code>), the <code>var [foo]</code> will have type <code>int</code>, and <code>var [foo] : float</code> will have type <code>float</code>.</p>

<hr />

<pre><code>terra foo(a : int, [luaexpr])
end
</code></pre>

<p><code>[luaexpr]</code> is an escape of a list of identifiers. In this case, it behaves similarly to an escape of a single identifier, but may also return a list of explicitly typed symbols which will be appended as parameters in the parameter list.</p>

<h2 id="quote">Quote</h2>

<p>Quotes are an operator from  <a href="http://www.cs.rice.edu/~taha/MSP/">multi-stage programming</a> that allows you to construct a Terra statement or expression from Lua code. When quotes are returned from escapes, metamethods, they code they contain is spliced into the surrounding Terra code.</p>

<hr />
<pre><code>`terraexpr
</code></pre>

<p>The backtick operator creates a quotation that contains a single terra <em>expression</em>. <code>terraexpr</code> can be any Terra expression. Any escapes that <code>terraexpr</code> contains will be evaluated when the expression is constructed.</p>

<hr />
<pre><code>quote
    terrastmts
end
</code></pre>

<p>The <code>quote</code> operator creates a quotation that contains a list of terra <em>statements</em>. These can only be spliced into Terra code where a statement would normally appear.</p>

<hr />
<pre><code>quote
    terrastmts
in
    terraexp1,terraexp2,...,terraexpN
end
</code></pre>

<p>The <code>quote</code> operation can also include an optional <code>in</code> statement that creates several expressions. This <code>quote</code> can be spliced into Terra code where an expression would normally appear and behaves like a function that returns multiple values.</p>

<hr />

<pre><code>terralib.isquote(t)
</code></pre>

<p>Returns true if <code>t</code> is a quote.</p>

<hr />

<pre><code>typ = quoteobj:astype()
</code></pre>

<p>Try to interpret this quote as if it were a Terra type object. This is normally used in <a href="#macros">macros</a> that expect a type as an argument (e.g. <code>sizeof([&amp;int])</code>). This function converts the <code>quote</code> object to the type (e.g. <code>&amp;int</code>).</p>

<hr />

<pre><code>typ = quoteobj:gettype()
</code></pre>

<p>If the quote object is a typed expression that was passed as an argument to a macro, this will return the type of the value that will result when it is evaluated.</p>

<hr />

<pre><code>luaval = quoteobj:asvalue()
</code></pre>

<p>Try to interpret this quote as if it were a simple Lua value. This is normally used in <a href="#macros">macros</a> that expect constants as an argument (e.g. the macro that truncates expressions <code>truncate(2,foo())</code>). Currently only supports very simple constants (e.g. numbers). Consider using an escape rather than a macro when you want to pass more complicated data structures to generative code.</p>

<hr />

<pre><code>quoteobj:printpretty()
</code></pre>

<p>Print out a visual representation of the code in this quote. Because quotes are not type-checked until they are placed into a function, this will print an untyped representation of the function.</p>

<h2 id="symbol">Symbol</h2>

<p>Symbols are abstract representations of Terra identifiers. They can be used in Terra code where an identifier is expected, e.g. a variable use, a variable definition, a function argument, a field name, a method name, a label (see also <a href="#escapes">Escapes</a>). They are similar to the symbols returned by LISP’s <code>gensym</code> function.</p>

<hr />

<pre><code>terralib.issymbol(s)
</code></pre>

<p>True if <code>s</code> is a symbol.</p>

<hr />

<pre><code>symbol([typ],[displayname])
</code></pre>

<p>Construct a new symbol. This symbol will be unique from any other symbol. <code>typ</code> is an optional type for the symbol. If the symbol is used in a variable definition without an explicit type, then the variable will use <code>typ</code> as its type. <code>displayname</code> is an optional name that will be printed out in error messages when this symbol is encountered.</p>

<h2 id="types">Types</h2>

<p>Type objects are first-class Lua values that represent the types of Terra objects. Terra’s built-in type system closely resembles that of low-level languages like C.  Type constructors are valid Lua expressions.  To support recursive types like linked lists, <a href="#exotypes_structs">structs</a> can be declared before their members and methods are fully specified. When a struct is declared but not defined, it is <em>incomplete</em> and cannot be used as value. However, pointers to incomplete types can be used as long as no pointer arithmetic is required. A type will become <em>complete</em> when it needs to be fully specified (e.g. we are using it in a compiled function, or we want to allocate a global variable with the type). At this point a full definition for the type must be available.</p>

<hr />

<pre><code>int int8 int16 int32 int64
uint  uint8 uint16 uint32 uint64
bool
float double
</code></pre>

<p>Primitive types.</p>

<hr />

<pre><code>&amp;typ
</code></pre>

<p>Constructs a pointer to <code>typ</code>.</p>

<hr />

<pre><code>typ[N]
</code></pre>

<p>Constructs an array of <code>N</code> instances of type <code>typ</code>. <code>N</code> must be a positive integer.</p>

<hr />
<pre><code>vector(typ,N)
</code></pre>

<p>Constructs a vector of <code>N</code> instances of type <code>typ</code>. <code>N</code> must be an integer and <code>typ</code> must be a primitive type. These types are abstractions vector instruction sets like <a href="http://en.wikipedia.org/wiki/Streaming_SIMD_Extensions">SSE</a>.</p>

<hr />

<pre><code>parameters -&gt; returntype
</code></pre>

<p>Constructs a function pointer. Both  <code>parameters</code>  and <code>returns</code> can be lists of types (e.g. <code>{int,int}</code>) or a single type <code>int</code>. If returntype is a list, a <code>tuple</code> of the values in the list is the type returned from the function.</p>

<hr />

<pre><code>struct { field0 : type2 , ..., fieldN : typeN }
</code></pre>

<p>Constructs a user-defined type, or exotype. Each call to <code>struct</code> creates a unique type since we use a <a href="http://en.wikipedia.org/wiki/Nominative_type_system">nominative</a> type systems. See <a href="#exotypes_structs">Exotypes</a> for more information.</p>

<hr />

<pre><code>tuple(type0,type1,...,typeN)
</code></pre>

<p>Constructs a tuple, which is a special kind of <code>struct</code> that contains the values <code>type0</code>… <code>typeN</code> as fields <code>obj._0</code> …. <code>obj._N</code>.  Unlike normal structs, each call to <code>tuple</code> with the same arguments will return the same type.</p>

<hr />

<pre><code>terralib.types.istype(t)
</code></pre>

<p>True if <code>t</code> is a type.</p>

<hr />

<pre><code>type:isprimitive()
</code></pre>

<p>True if <code>type</code> is a primitive type (see above).</p>

<hr />

<pre><code>type:isintegral()
</code></pre>

<p>True if <code>type</code> is any integer type. </p>

<hr />

<pre><code>type:isfloat()
</code></pre>

<p>True if <code>type</code> is <code>float</code> or <code>double</code>.</p>

<hr />

<pre><code>type:isarithmetic()
</code></pre>

<p>True if <code>type</code> is integral or float.</p>

<hr />

<pre><code>type:islogical()
</code></pre>

<p>True if <code>type</code> is <code>bool</code> (we might eventually supported sized boolean types that are closer to the machine representation of flags in vector instructions).</p>

<hr />

<pre><code>type:canbeord()
</code></pre>

<p>True if the <code>type</code> can be used in expressions <code>or</code> and <code>and</code> (i.e. integral and logical but not float).</p>

<hr />

<pre><code>type:ispointer()
</code></pre>

<p>True if <code>type</code> is a pointer. <code>type.type</code> is the type pointed to.</p>

<hr />

<pre><code>type:isarray()
</code></pre>

<p>True if <code>type</code> is an array. <code>type.N</code> is the length. <code>type.type</code> is the element type.</p>

<hr />

<pre><code>type:isfunction()
</code></pre>

<p>True if <code>type</code> is a function (not a function pointer). <code>type.parameters</code> is a list of parameter types. <code>type.returntype</code> is return type. If a function returns multiple values this type will be a <code>tuple</code> of the values. </p>

<hr />

<pre><code>type:isstruct()
</code></pre>

<p>True if <code>type</code> is a <a href="#exotypes_structs">struct</a>.</p>

<hr />

<pre><code>type:ispointertostruct()
</code></pre>

<p>True if <code>type</code> is a pointer to a struct.</p>

<hr />

<pre><code>function types.type:ispointertofunction()
</code></pre>

<p>True if <code>type</code> is a pointer to a function.</p>

<hr />

<pre><code>type:isaggregate() 
</code></pre>

<p>True if <code>type</code> is an array or a struct (any type that can hold arbitrary types).</p>

<hr />

<pre><code>type:iscomplete()
</code></pre>

<p>True if the <code>type</code> is fully defined and ready to use in code. This is always true for non-aggregate types. For aggregate types, this is true if all types that they contain have been defined. Call type:complete() to force a type to become complete.</p>

<hr />

<pre><code>type:isvector()
</code></pre>

<p>True if the <code>type</code> is a vector. <code>type.N</code> is the length. <code>type.type</code> is the element type.</p>

<hr />

<pre><code>type:(isprimitive|isintegral|isarithmetic|islogical|canbeord)orvector()
</code></pre>

<p>True if the <code>type</code> is a primitive type with the requested property, or if it is a vector of a primitive type with the requested property.</p>

<hr />

<pre><code>type:complete()
</code></pre>

<p>Forces the type to be complete. For structs, this will calculate the layout of the struct (possibly calling <code>__getentries</code> and <code>__staticinitialize</code> if defined), and recursively complete any types that this type references.</p>

<h2 id="exotypes-structs">Exotypes (Structs)</h2>

<p>We refer to Terra’s way of creating user-defined aggregate types as exotypes
because they are defined <em>external</em> to Terra itself, using a Lua API.
The design tries to provide the raw mechanisms for defining the behavior of user-defined types without imposing any language-specific policies. Policy-based class systems such as those found in Java or C++ can then be created as libraries on top of these raw mechanisms. For conciseness and familiarity, we use the keyword <code>struct</code> to refer to these types in the language itself.</p>

<p>We also provide syntax sugar for defining exotypes for the most common cases. 
This section first discuses the Lua API itself, and then shows how the syntax sugar translates into it.</p>

<p>More information on the rationale for this design is available in our <a href="publications.html">publications</a>.</p>

<h3 id="lua-api-1">Lua API</h3>

<p>A new user-defined type is created with the following call:</p>

<pre><code>    mystruct = terralib.types.newstruct([displayname])
</code></pre>

<p><code>displayname</code> is an optional name that will be displayed by error messages, but each call to <code>newstruct</code> creates a unique type regardless of name (We use a <a href="http://en.wikipedia.org/wiki/Nominative_type_system">nominative</a> type system. The type can then be used in Terra programs:</p>

<pre><code>terra foo()
    var a : mystruct --instance of mystruct type
end
</code></pre>

<p>The memory layout and behavior of the type when used in Terra programs is defined by setting <em>property functions</em> in the types <code>metamethods</code> table:</p>

<pre><code>mystruct.metamethods.myproperty = function ...
</code></pre>

<p>When the Terra typechecker needs to know information about the type, it will call the property function in the metamethods table of the type. If a property is not set, it may have a default behavior which is discussed for each property individually.</p>

<p>The following fields in <code>metamethods</code> are supported: </p>

<hr />

<pre><code>entries = __getentries(self)
</code></pre>

<p>A <em>Lua</em> function that determines the fields in a struct computationally. The <code>__getentries</code> function will be called by the compiler once when it first requires the list of entries in the struct. Since the type is not yet complete during this call, doing anything in this method that requires the type to be complete will result in an error. <code>entries</code> is a <a href="#list">List</a> of field entries. Each field entry is one of:</p>

<ul>
  <li>A table <code>{ field = stringorsymbol, type = terratype }</code>, specifying a named field.</li>
  <li>A table <code>{stringorsymbol,terratype}</code>, also specifying a named field.</li>
  <li>A <a href="#list">List</a> of field entries that will be allocated together in a union sharing the same memory. </li>
</ul>

<p>By default, <code>__getentries</code> just returns the <code>self.entries</code> table, which is set by the <code>struct</code> definition syntax.</p>

<hr />

<pre><code>method = __getmethod(self,methodname)
</code></pre>

<p>A <em>Lua</em> function looks up a method for a struct when the compiler sees a method invocation <code>mystruct:mymethod(...)</code> or a static method lookup <code>mystruct.mymethod</code>.  <code>mymethod</code> may be either a string or a <a href="#symbol">symbol</a>. This metamethod will be called by the compiler for every static invocation of <code>methodname</code> on this type. Since it can be called multiple times for the same <code>methodname</code>, any expensive operations should be memoized across calls. 
<code>method</code> may be a Terra function, a Lua function, or a <a href="#macro">macros</a> which will run during typechecking.  </p>

<p>Assuming that <code>__getmethod</code> returns the value <code>method</code>, then in Terra code the expression <code>myobj:mymethod(arg0,...argN)</code> turns into <code>[method](myobj,arg0,...,argN)</code> if type of <code>myobj</code> is <code>T</code>. </p>

<p>If the type of <code>myobj</code> is <code>&amp;T</code> then it desugars to <code>[method](@myobj,arg0,...,argN)</code>.
If, when a method is invoked, <code>myobj</code> has type <code>T</code> but the formal parameter has type <code>&amp;T</code> then the argument will be automatically converted to a pointer by taking its address. This <em>method receiver cast</em> allows method calls on objects to modify the object.</p>

<p>By default, <code>__getmethod(self,methodname)</code> will return <code>self.methods[methodname]</code>, which is set by the method definition syntax sugar. If the table does not contain the method, then the typechecker will call <code>__methodmissing</code> as described below.</p>

<hr />

<pre><code>__staticinitialize(self)
</code></pre>

<p>A <em>Lua</em> function called after the type is complete but before the compiler returns to user-defined code. Since the type is complete, you can now do things that require a complete type such as create vtables, or examine offsets using the <code>terralib.offsetof</code>. The static initializers for entries in a struct will run before the static initializer for the struct itself.</p>

<hr />

<pre><code>castedexp = __cast(from,to,exp)`
</code></pre>

<p>A <em>Lua</em> function that can define conversions between your type and another type. <code>from</code> is the type of <code>exp</code>, and <code>to</code> is the type that is required.  For type <code>mystruct</code>, <code>__cast</code> will be called when either <code>from</code> or <code>to</code> is of type <code>mystruct</code> or type <code>&amp;mystruct</code>. If there is a valid conversion, then the method should return <code>castedexp</code> where <code>castedexp</code> is the expression that converts <code>exp</code> to <code>to</code>. Otherwise, it should report a descriptive error using the <code>error</code> function. The Terra compiler will try any applicable <code>__cast</code> metamethod until it finds one that works (i.e. does not call <code>error</code>).</p>

<hr />

<pre><code>__methodmissing(mymethod,myobj,arg1,...,argN)
</code></pre>

<p>When a method is called <code>myobj:mymethod(arg0,...,argN)</code> and <code>__getmethod</code> is not set, then the macro <code>__methodmissing</code> will be called if <code>mymethod</code> is not found in the method table of the type. It should return a Terra <a href="#quote">quote</a> to use in place of the method call.</p>

<hr />

<pre><code>__entrymissing(entryname,myobj)
</code></pre>

<p>If <code>myobj</code> does not contain the filed <code>entryname</code>, then <code>__entrymissing</code> will be called whenever the typechecker sees the expression <code>myobj.entryname</code>. It should return a Terra <a href="#quote">quote</a> to use in place of the field.</p>

<p>Custom operators:</p>

<pre><code>__sub, __add, __mul, __div, __mod, __lt, __le, __gt, __ge,
__eq, __ne, __and, __or, __not, __xor, __lshift, __rshift, 
__select, __apply
</code></pre>

<p>Can be either a Terra method, or a macro. These are invoked when the type is used in the corresponding operator. <code>__apply</code> is used for function application, and <code>__select</code> for <code>terralib.select</code>.  In the case of binary operators, at least one of the two arguments will have type <code>mystruct</code>. The interface for custom operators hasn’t been heavily tested and is subject to change.</p>

<hr />

<pre><code>__typename(self)
</code></pre>

<p>A <em>Lua</em> function that generates a string that names the type. This name will be used in error messages and <code>tostring</code>.</p>

<h3 id="syntax-sugar">Syntax Sugar</h3>

<hr />

<pre><code>[local] struct mystruct
</code></pre>

<p><em>Struct declaration</em> If <code>mystruct</code> is not already a Terra struct, it creates a new struct by calling <code>terralib.types.newstruct("mystruct")</code> and stores it in the Lua variable <code>mystruct</code>. If <code>mystruct</code> is already a struct, then it does not modify it. If the optional <code>local</code> keyword is used, then <code>mystruct</code> is first defined as a new local Lua variable.  When used without the <code>local</code> keyword, <code>mystruct</code> can be a table specifier (e.g. <code>a.b.c</code>).</p>

<hr />

<pre><code>[local] struct mystruct {
    field0 : type0;
    ...
    union {
        fieldUnion0 : type1;
        fieldUnion1 : type2;
    }
    ...
    fieldN : typeN;
}
</code></pre>

<p><em>Struct definition</em>. If <code>mystruct</code> is not already a Struct, then it creates a new struct with the behavior of struct declarations. It then fills in the <code>entries</code> table of the struct with the fields and types specified in the body of the definition. The <code>union</code> block can be used to specify that a group of fields should share the same location in memory. If <code>mystruct</code> was previously given a definition, then defining it again will result in an error.</p>

<hr />

<pre><code>terra mystruct:mymethod
</code></pre>

<p><em>Method declaration</em>. Creates a new Terra function with definitions at <code>mystruct.methods.mymethod</code> if one does not already exist.</p>

<hr />

<pre><code>terra mystruct:mymethod(arg0 : type0,..., argN : typeN)
    ...
end
</code></pre>

<p><em>Method definition</em>. If <code>mystruct.methods.mymethod</code> is not a Terra function, it creates one. Then it adds the method definition. The formal parameter <code>self</code> with type <code>&amp;mystruct</code> will be added to beginning of the formal parameter list.</p>

<h2 id="c-backwards-compatibility">C Backwards Compatibility</h2>

<p>Terra uses the <a href="http://clang.llvm.org">Clang</a> frontend to allow Terra code to be backwards compatible with C. The current implementation of this functionality is somewhat limited. For instance, including a C header will only import the functions and any types that those functions refer to, but will not import global variables, enums, or types that are not used by functions. This will be improved in the future.</p>

<hr />

<pre><code>table = terralib.includecstring(code,...)
</code></pre>

<p>Import the string <code>code</code> as C code.  Flags to Clang can be passed as additional arguments (e.g. <code>includecstring(code,"-I","..")</code>). Returns a Lua table mapping the names of included C functions to Terra <a href="#function">function</a> objects, and names of included C types (e.g. typedefs) to Terra <a href="#types">types</a>.</p>

<hr />

<pre><code>table = terralib.includec(filename,...)
</code></pre>

<p>Similar to <code>includecstring</code> except that C code is loaded from <code>filename</code>. This uses Clangs default path for header files. <code>...</code> allows you to pass additional arguments to Clang (including more directories to search).</p>

<hr />

<pre><code>terralib.linklibrary(filename)
</code></pre>

<p>Load the dynamic library in file  <code>filename</code>. If header files imported with <code>includec</code> contain declarations whose definitions are not linked into the executable in which Terra is run, then it is necessary to dynamically load the definitions with <code>linklibrary</code>. This situation arises when using external libraries with the <code>terra</code> REPL/driver application. <code>filename</code> can also be an LLVM bitcode file with extension <code>.bc</code> generated with <code>clang</code> or <code>clang++</code>:</p>

<pre><code>clang++ -O3 -emit-llvm -c mycode.cpp -o mybitcode.bc
</code></pre>

<p>In this case, the code is loaded as bitcode rather than machine code. This allows for more aggressive optimization (such as inlining the function calls) but will take longer to initialize in Terra since it must be compiled to machine code.</p>

<h2 id="managing-terra-values-from-lua">Managing Terra Values from Lua</h2>

<p>We provide wrappers around LuaJIT’s <a href="http://luajit.org/ext_ffi.html">FFI API</a> that allow you to allocate and manipulate Terra objects directly from Lua.</p>

<hr />

<pre><code>terralib.typeof(obj)
</code></pre>

<p>Return the Terra type of <code>obj</code>. Object must be a LuaJIT <code>ctype</code> that was previously allocated using calls into the Terra API, or as the return value of a Terra function. </p>

<hr />

<pre><code>terralib.new(terratype,[init])
</code></pre>

<p>Wrapper around LuaJIT’s <code>ffi.new</code>. Allocates a new object with the type <code>terratype</code>. <code>init</code> is an optional initializer that follows the <a href="#converting_between_lua_values_and_terra_values">rules</a> for converting between Terra values and Lua values. This object will be garbage collected if it is no longer reachable from Lua.</p>

<hr />

<pre><code>terralib.sizeof(terratype)
</code></pre>

<p>Wrapper around <code>ffi.typeof</code>. Completes the <code>terratype</code> and returns its size in bytes.</p>

<hr />

<pre><code>terralib.offsetof(terratype,field)
</code></pre>

<p>Wrapper around <code>ffi.offsetof</code>. Completes the <code>terratype</code> and returns the offset in bytes of <code>field</code> inside <code>terratype</code>.</p>

<hr />

<pre><code>terralib.cast(terratype,obj)
</code></pre>

<p>Wrapper around <code>ffi.cast</code>. Converts <code>obj</code> to <code>terratype</code> using the <a href="#converting_between_lua_values_and_terra_values">rules</a> for converting between Terra values and Lua values.</p>

<h2 id="loading-terra-code">Loading Terra Code</h2>

<p>These functions allow you to load chunks of mixed Terra-Code code at runtime.</p>

<hr />

<pre><code>terralib.load(readerfn)
</code></pre>

<p>Lua equivalent of C API call <code>terra_load</code>. <code>readerfn</code> behaves the same as in Lua’s <code>load</code> function.</p>

<hr />

<pre><code>terralib.loadstring(s)
</code></pre>

<p>Lua equivalent of C API call <code>terra_loadstring</code>. </p>

<hr />

<pre><code>terralib.loadfile(filename)
</code></pre>

<p>Lua equivalent of C API call <code>terra_loadfile</code>.</p>

<hr />

<pre><code>terralib.require(modulename)
</code></pre>

<p>Load the terra code <code>modulename</code>. <code>require</code> first checks if <code>modulename</code> has already been loaded by a previous call to <code>require</code>, returning the previously loaded results if available. Otherwise it searches <code>package.path</code> for the module. <code>package.path</code> is a semi-colon separated list of templates, e.g.:</p>

<pre><code>"lib/?.t;./?.t"
</code></pre>

<p>The <code>modulename</code> is first converted into a path by replacing any <code>.</code> with a directory separator, <code>/</code>. Then each template is tried until a file is found. For instance, using the example path, the call <code>terralib.require("foo.bar")</code> will try to load <code>lib/foo/bar.t</code> or <code>foo/bar.t</code>. If a file is found, then <code>require</code> will return the result of calling <code>terralib.loadfile</code> on the file. By default, <code>package.path</code> is set to the environment variable <code>LUA_PATH</code>. If <code>LUA_PATH</code> is not set then <code>package.path</code> will contain <code>./?.t</code> as a path.</p>

<h2 id="saving-terra-code">Saving Terra Code</h2>

<hr />

<pre><code>terralib.saveobj(filename [, filetype], functiontable[, arguments])
</code></pre>

<p>Save Terra code to an external representation such as an object file, or executable. <code>filetype</code> can be one of <code>"object"</code> (an object file <code>*.o</code>), <code>"bitcode"</code> (LLVM bitcode <code>*.bc</code>), <code>"llvmir"</code> (LLVM textual IR <code>*.ll</code>), or <code>"executable"</code> (no extension).
If <code>filetype</code> is missing then it is inferred from the extension. <code>functiontable</code> is a table from strings to Terra functions. These functions will be included in the code that is written out with the name given in the table.
<code>arguments</code> is an additional list that can contain flags passed to the linker when <code>filetype</code> is <code>"executable"</code>. If <code>filename</code> is <code>nil</code>, then the file will be written in memory and returned as a Lua string.</p>

<h2 id="converting-between-lua-values-and-terra-values">Converting between Lua values and Terra values</h2>

<p>When compiling or invoking Terra code, it is necessary to convert values between Terra and Lua. Internally, we implement this conversion on top of LuaJIT’s <a href="http://luajit.org/ext_ffi.html">foreign-function interface</a>, which makes it possible to call C functions and use C values directly from Lua. Since Terra type system is similar to that of C’s, we can reuse most of this infrastructure.  </p>

<h3 id="converting-lua-values-to-terra-values-of-known-type">Converting Lua values to Terra values of known type</h3>

<p>When converting Lua values to Terra, we sometimes know the expected type (e.g. when the type is specified in a <code>terralib.cast</code> or <code>terralib.constant</code> call). In the case, we follow LuaJIT’s <a href="http://luajit.org/ext_ffi_semantics.html#convert_fromlua">conversion semantics</a>, substituting the equivalent C type for each Terra type.</p>

<h3 id="converting-lua-values-to-terra-values-with-unknown-type">Converting Lua values to Terra values with unknown type</h3>

<p>When a Lua value is used directly from Terra code through an <a href="#escapes">escape</a>), or a Terra value is create without specifying the type (e.g. <code>terralib.constant(3)</code>), then we attempt the infer the type of the object. If successful, then the standard conversion is applied. If the <code>type(value)</code> is:</p>

<ul>
  <li><code>cdata</code> – If it was previously allocated from the Terra API, or returned from Terra code, then it is converted into the Terra type equivalent to the <code>ctype</code> of the object.</li>
  <li><code>number</code> – If <code>floor(value) == value</code> and value can fit into an <code>int</code> then the type is an <code>int</code> otherwise it is <code>double</code>.</li>
  <li><code>boolean</code> – the type is <code>bool</code>.</li>
  <li><code>string</code> – converted into a <code>rawstring</code> (i.e. a <code>&amp;int8</code>). We may eventually add a special string type.</li>
  <li>otherwise – the type cannot be inferred. If you know the type of the object, then you use a <code>terralib.cast</code> function to specify it. </li>
</ul>

<h3 id="compile-time-conversions">Compile-time conversions</h3>

<p>When a Lua value is used as the result of an <a href="#escapes">escape</a> operator in a Terra function, additional conversions are allowed:</p>

<ul>
  <li><a href="#global_variable">Global Variable</a> – value becomes a lvalue reference to the global variable in Terra code.</li>
  <li><a href="#symbol">Symbol</a> – value becomes a lvalue reference to the variable defined using the symbol. If the variable is not in scope, this will become a compile-time error.</li>
  <li><a href="#quote">Quote</a> – the code defined in the quote will be spliced into the Terra code. If the quote contains only statements, it can only be spliced in where a statement appears.</li>
  <li><a href="#constant">Constant</a> – the constant is spliced into the Terra code.</li>
  <li>Lua Function – If used in a function call, the lua function is <code>terralib.cast</code> to the Terra function type that has no return values, and whose parameters are the Terra types of the actual parameters of the function call. If not use in a function call, results in an error.</li>
  <li><a href="#macro">Macro</a> – If used as a function call, the macro will be run at compile time. The result of the macro will then be convert to Terra using the compile-time conversion rules and spliced in place.</li>
  <li><a href="#types">Type</a> – If used as an argument to a macro call, it will be passed-through such that calling <code>arg:astype()</code> will return the value. If used as a function call (e.g. <code>[&amp;int](v)</code>, it acts as an explicit cast to that type.</li>
  <li><a href="#list">List</a> or a rawlist (as classified by <code>terralib.israwlist</code>) – Each member of the list is recursively converted to a Lua value using compile-time conversions (excluding the conversions for Lists). If used as a statement or where multiple expressions can appear, all values of the list are spliced in place. Otherwise, if used where only a single expression can appear, the list is truncated to 1 value.</li>
  <li><code>cdata</code> aggregates (structs and arrays) – If a Lua <code>cdata</code> aggregate of Terra type <code>T</code> is referenced directly in Terra code, the value in Terra code will be an lvalue reference of type <code>T</code> to the Lua-allocated memory that holds that aggregate. </li>
  <li>otherwise – the value is first converted to a Terra vlue using the standard rules for converting Lua to Terra values with unknown type. The resulting value is then spliced in place as a <em>constant</em>.</li>
</ul>

<h3 id="converting-terra-values-to-lua-values">Converting Terra values to Lua values</h3>

<p>When converting Terra values back into Lua values (e.g. from the results of a function call), we follow LuaJIT’s <a href="http://luajit.org/ext_ffi_semantics.html#convert_tolua">conversion semantics</a> from C types to Lua objects, substituting the equivalent C type for each Terra type.</p>

<h2 id="asynchronous-compilation">Asynchronous Compilation</h2>

<p>When the Terra compiler encounters a <a href="#macros">macro</a> or <a href="#exotypes_structs">metamethod</a>, it can call back into user-defined code. The user-defined code in a macro or metamethod might need to create additional Terra functions or types, and try to compile and run Terra functions. This means user-defined code can <em>re-enter</em> the Terra compiler. For the most part this behavior works fine.  However, it is possible for user-defined code to try to compile a function or complete a type that is <em>already</em> being compiled. In this case, the call to <code>compile</code> will report an error since it cannot fulfill the (circular) request. It is possible that the user-defined code doesn’t need the compilation to finish while inside the macro, but only needs the compilation finished before the compiler returns control to user code that called it synchronously.</p>

<p>If the <code>async</code> argument to a compilation function is not <code>nil</code> or <code>false</code>, then the function is called asynchronous. It may return before the compilation is complete and only needs to be finished by the time the compiler returns to a synchronous call. Furthermore, if <code>async</code> is a Lua function, then it will be registered as a callback that will be invoked as soon as the requested compilation operation has completed (in the simple cases where there is no recursive loop, it will just be invoked immediately). </p>

<p>Situations requiring callbacks arise when building class systems that have virtual function tables (vtables). To build a vtable, you need to compile the concrete implementations of the type’s methods and then fill in the vtable with these values. However, it is possible that these functions were already being compiled. In this case, we still need to compile these functions and fill-in the vtable, but cannot finish this task inside the type’s <code>__staticinitialize</code> metamethod.  By calling compile asynchronously and registering a callback that fills in the vtable, we can guarantee that the vtable is filled in before the call to the compiler returns while allowing <code>__staticinitialize</code> to return before the vtable is complete. Callbacks are guaranteed to be invoked before returning to user-defined code that invoked the compiler synchronously. So we know that the vtable will be initialized before any of this newly compiled code is run.</p>

<h2 id="debugging">Debugging</h2>

<p>Terra provides a few library functions to help debug and performance tune code. Except for <code>currenttimeinseconds</code>,
these debugging facilities are only available on OSX and Linux.</p>

<hr />

<pre><code>terralib.currenttimeinseconds()
</code></pre>

<p>A Lua function that returns the current time in seconds since some fixed time in the past. Useful for performancing tuning Terra code.</p>

<hr />

<pre><code>terra terralib.traceback(uctx : &amp;opaque)
</code></pre>

<p>A Terra function that can be called from Terra code to print a stack trace. If <code>uctx</code> is <code>nil</code> then this will print the current stack. <code>uctx</code> can also be a pointer to a <code>ucontext_t</code> object (see <code>ucontext.h</code>) and will print the stack trace for that context.
By default, the interpreter will print this information when a program segfaults.</p>

<hr />

<pre><code>terra terralib.backtrace(addresses : &amp;&amp;opaque, naddr : uint64, ip : &amp;opaque, frameaddress : &amp;opaque)
</code></pre>

<p>A low-level interface used to get the return addresses from a machine stack. <code>addresses</code> must be a pointer to a buffer that can hold at least <code>naddr</code> pointers.
<code>ip</code> should be the address of the current instruction and will be the first entry in <code>addresses</code>, while <code>frameaddress</code> should be the value of the base pointer.
<code>addresses</code> will be filled with the return addresses on the stack. Requires debugging mode to be enabled (<code>-g</code>) for it to work correctly.</p>

<hr />

<pre><code>terra terralib.disas(addr : &amp;opaque, nbytes : uint64, ninst : uint64)
</code></pre>

<p>A low-level interface to the disassembler. Print the disassembly of instructions starting at <code>addr</code>. Will print <code>nbytes</code> of instructions or <code>ninst</code> instructions, whichever causes more instructions to be printed.</p>

<hr />

<pre><code>terra terralib.lookupsymbol(ip : &amp;opaque, addr : &amp;&amp;opaque, size : &amp;uint64, name : &amp;rawstring, namelength : &amp;uint64) : bool
</code></pre>

<p>Attempts to look up information about a Terra function given a pointer  <code>ip</code> to any instruction in the function. Returns <code>true</code> if successful,
filling in <code>addr</code> with the start of the function and <code>size</code> with the size of the function in bytes. Fills in <code>name</code> with a pointer to a fixed-width string of to <code>namemax</code> characters holding the function name.</p>

<hr />

<pre><code>terra terralib.lookupline(fnaddr : &amp;opaque, ip : &amp;opaque, filename : &amp;rawstring, namelength : &amp;uint64, line : &amp;uint64) : bool
</code></pre>

<p>Attempts to look up information about a Terra instruction given a pointer <code>ip</code> to the instruction and a pointer <code>fnaddr</code> to the start of the function containing it. 
Returns <code>true</code> if successful, filling in <code>line</code> with line on which the instruction occured and <code>filename</code> with a pointer to a fixed-width string of to <code>namemax</code> characters holding the filename.
Fills up to <code>namemax</code> characters of the function’s name into <code>name</code>.</p>

<h1 id="embedded-language-api">Embedded Language API</h1>

<p>Language extensions in the Terra system allow you to create custom Lua statements and expressions that you can use to implement your own embedded language. Each language registers a set of entry-point keywords that indicate the start of a statement or expression in your language. If the Terra parser sees one of these keywords at the beginning of a Lua expression or statement, it will switch control of parsing over to your language, where you can  parse the tokens into an abstract syntax tree (AST), or other intermediate representation. After creating the AST, your language then returns a <em>constructor</em> function back to Terra parser. This function will be called during execution when your statement or expression should run.</p>

<p>This guide introduces language extensions with a simple stand-alone example, and shows how to register the extension with Terra. We then expand on this example by showing how it can interact with the Lua environment. The end of the guide documents the language extension interface, and the interface to the lexer in detail.</p>

<h2 id="a-simple-example">A Simple Example</h2>

<p>To get started, let’s add a simple language extension to Lua that sums up a list of numbers. The syntax will look like <code>sum 1,2,3 done</code>, and when run it will sum up the numbers, producing the value <code>6</code>. A language extension is defined using a Lua table. Here is the table for our language</p>

<pre><code>local sumlanguage = {
  name = "sumlanguage"; --name for debugging
  -- list of keywords that will start our expressions
  entrypoints = {"sum"}; 
  keywords = {"done"}; --list of keywords specific to this language
   --called by Terra parser to enter this language
  expression = function(self,lex)
    --implementation here
  end;
}
</code></pre>

<p>We list <code>"sum"</code> in the <code>entrypoints</code> list since we want Terra to hand control over to our language when it encounters this token at the beginning of an expression. We also list <code>"done"</code> as a keyword since we are using it to end our expression. When the Terra parser sees the <code>sum</code> token it will call the <code>expression</code> function passing in an interface to the lexer, <code>lex</code>. Here is the implementation:</p>

<pre><code>expression = function(self,lex)
  local sum = 0
  lex:expect("sum") --first token should be "sum"
  if not lex:matches("done") then
    repeat
      --parse a number, return its value
      local v = lex:expect(lex.number).value 
      sum = sum + v
    --if there is a comma, consume it and continue
    until not lex:nextif(",") 
  end

  lex:expect("done")
  --return a function that is run 
  --when this expression would be evaluated by Lua
  return function(environment_function)
    return sum
  end
end
</code></pre>

<p>We use the <code>lex</code> object to interact with the tokens. The interface is documented below. Since the statement only allows numeric constants, we can perform the summation during parsing. Finally, we return a <em>constructor</em> function that will be run every time this statement is executed. We can use it in Lua code like so:</p>

<pre><code>print(sum 1,2,3 done) -- prints 6
</code></pre>

<p>The file <code>tests/lib/sumlanguage.t</code> contains the code for this example, and <code>tests/sumlanguage1.t</code> has an example of its use.</p>

<h2 id="loading-and-running-the-language">Loading and Running the Language</h2>
<p>In order to use our language extension, it needs to be <em>imported</em>.
The language extension mechanism includes an <code>import</code> statment to load the language extension:</p>

<pre><code>import "lib/sumlanguage" --active the new parsing rules
result = sum 1,2,3 done
</code></pre>

<p>Since <code>import</code> statements are evaluated at <em>parse</em> time, the argument must be a string literal. 
The parser will then call <code>terralib.require</code> on the string literal to load the language extension file.
The file specified should <em>return</em> the Lua table describing your language:</p>

<pre><code>local sumlanguage = { ... } --fill in your table
return sumlanguage
</code></pre>

<p>The imported language will be enabled only in the local scope where the import statement occured:</p>

<pre><code>do
    import "lib/sumlanguage"
    result = sum 1,2,3 done --ok, in scope
    if result == 6 then
        result = sum 4,5 done -- ok, still in scope
    end
end
result = sum 6,7 done --error! sumlanguage is not in scope
</code></pre>

<p>Multiple languages can be imported in the same scope as long as their <code>entrypoints</code> do not overlap.
If their entrypoints do overlap, the languages can still be imported in the same file as long as the <code>import</code> statements occur in different scopes.</p>

<h2 id="interacting-with-lua-symbols">Interacting with Lua symbols</h2>

<p>One of the advantages of Terra is that it shares the same lexical scope as Lua, making it easy to parameterize Terra functions. Extension languages can also access Lua’s static scope. Let’s extend our sum language so that it supports both constant numbers, as well as Lua variables:</p>

<pre><code>local a = 4
print(sum a,3 done) --prints 7
</code></pre>

<p>To do this we need to modify the code in our <code>expression</code> function:</p>

<pre><code>expression = function(self,lex)
  local sum = 0
  local variables = terralib.newlist()
  lex:expect("sum")
  if not lex:matches("done") then
    repeat
      if lex:matches(lex.name) then --if it is a variable
        local name = lex:next().value
        --tell the Terra parser 
        --we will access a Lua variable, 'name'
        lex:ref(name) 
        --add its name to the list of variables
        variables:insert(name) 
      else
        sum = sum + lex:expect(lex.number).value
      end
    until not lex:nextif(",")
  end
  lex:expect("done")
  return function(environment_function)
    --capture the local environment
    --a table from variable name =&gt; value
    local env = environment_function() 
    local mysum = sum
    for i,v in ipairs(variables) do
      mysum = mysum + env[v]
    end
    return mysum
  end
end
</code></pre>

<p>Now an expression can be a variable name (<code>lex.name</code>). Unlike constants, we don’t know the value of this variable at parse time, so we cannot calculate the entire sum before execution. Instead, we save the variable name (<code>variables:insert(name)</code>) and tell the Terra parser that will need the value of this variable at runtime (<code>lex:ref(name)</code>).  In our <em>constructor</em> we now capture the local lexical environment by calling the <code>environment_function</code> parameter, and look up the values of our variables in the environment to compute the sum. It is important to call <code>lex:ref(name)</code>. If we had not called it, then this environment table will not contain the variables we need.</p>

<h2 id="recursively-parsing-lua">Recursively Parsing Lua</h2>

<p>Sometimes in the middle of your language you may want to call back into the Lua parser to parse an entire Lua expression. For instance, Terra types are Lua expressions:</p>

<pre><code>var a : int = 3
</code></pre>

<p>In this example, <code>int</code> is actually a Lua expression.</p>

<p>The method <code>lex:luaexpr()</code> will parse a Lua expression. It returns a Lua function that implements the expression. This functions takes the local lexical environment, and returns the value of the expression in that environment. As an example, let’s add a concise way of specifying a single argument Lua function, <code>def(a) exp</code>, where <code>a</code> is a single argument and <code>exp</code> is a Lua expression. This is similar to Pythons <code>lambda</code> statement. Here is our language extension:</p>

<pre><code>{
  name = "def";
  entrypoints = {"def"};
  keywords = {};
  expression = function(self,lex)
    lex:expect("def")
    lex:expect("(")
    local formal = lex:expect(lex.name).value
    lex:expect(")")
    local expfn = lex:luaexpr()
    return function(environment_function)
      --return our result, a single argument lua function
      return function(actual)
        local env = environment_function()
        --bind the formal argument 
        --to the actual one in our environment
        env[formal] = actual
        --evaluate our expression in the environment
        return expfn(env)
      end
    end
  end;
}
</code></pre>

<p>The full code for this example can be found in <code>tests/lib/def.t</code> and <code>tests/def1.t</code>.</p>

<h2 id="extending-statements">Extending Statements</h2>

<p>In addition to extending the syntax of expressions, you can also define new syntax for statements and local variable declarations:</p>

<pre><code>terra foo() end -- a new statement
local terra foo() end -- a new local variable declaration
</code></pre>

<p>This is done by specifying the <code>statement</code> and <code>localstatement</code> functions in your language table. These function behave the same way as the <code>expression</code> function, but they can optionally return a list of names that they define. The file <code>test/lib/def.t</code> shows how this would work for the <code>def</code> constructor to support statements:</p>

<pre><code>def foo(a) luaexpr --defines global variable foo
local def bar(a) luaexpr --defins local variable bar
</code></pre>

<h2 id="higher-level-parsing-via-pratt-parsers">Higher-Level Parsing via Pratt Parsers</h2>

<p>Writing a parser that directly uses the lexer interface can be tedious. One simple approach that makes parsing easier (especially for expressions with multiple precedence levels) is Pratt parsing, or top-down precedence parsing (for more information, see http://javascript.crockford.com/tdop/tdop.html). We’ve provided a library built on top of the Lexer interface to help do this. It can be found, along with documentation of the API in <code>tests/lib/parsing.t</code>. An example extension written using this library is found in <code>tests/lib/pratttest.t</code> and an example program using it in <code>tests/pratttest1.t</code>. </p>

<h2 id="the-language-and-lexer-api">The Language and Lexer API</h2>

<p>This section decribes the API for defining languages and interacting with the <code>lexer</code> object in detail.</p>

<h3 id="language-table">Language Table</h3>
<p>A language extension is defined by a Lua table containing the following fields.</p>

<hr />

<pre><code>name
</code></pre>

<p>a name for your language used for debugging</p>

<hr />

<pre><code>entrypoints
</code></pre>

<p>A Lua list specifying the keywords that can begin a term in your language. These keywords must not be a Terra or Lua keyword and cannot overlap with entry-points for other loaded languages (In the future, we may allow you to rename entry-points when you load a language to resolve conflicts). These keywords must be valid Lua identifiers (i.e. they must be alphanumeric and cannot start with anumber). In the future, we may expand this to allow arbitrary operators (e.g. <code>+=</code>) as well.</p>

<hr />

<pre><code>keywords
</code></pre>

<p>A Lua list specifying any additional keywords used in your language. Like entry-points, these also must be valid identifiers. A keyword in Lua or Terra is always considered a keyword in your language, so you do not need to list them here. </p>

<hr />

<pre><code>expression
</code></pre>

<p>(Optional) A Lua method <code>function(self,lexer)</code> that is called whenever the parser encounters an entry-point keyword at the beginning of a Lua expression. <code>self</code> is your language object, and <code>lexer</code> is a Lua object used to interact with Terra’s lexer to retrieve tokens and report errors. Its API is decribed below. The <code>expression</code> method should return a <em>constructor</em> function <code>function(environment_function)</code>. The constructor is called every time the expression is evaluated and should return the value of the expression as it should appear in Lua code.  Its argument, <code>environment_function</code>, is a function  that when called, returns the local lexical environment as Lua table from  variable names to values.</p>

<hr />

<pre><code>statement 
</code></pre>

<p>(Optional) A Lua method <code>function(self,lexer)</code> called when the parser encounters an entry-point keyword at the beginning of a Lua <em>statement</em>. Similar to <code>expression</code>, it returns a constructor function. Additionally, it can return a second argument that is a list of assignements that the statment performs to variables. For instance, the value <code>{ "a", "b", {"c","d"} }</code> will behave like the Lua statment <code>a,b,c.d = constructor(...)</code></p>

<hr />

<pre><code>localstatement
</code></pre>

<p>(Optional) A Lua method <code>function(self,lexer)</code> called when the parser encounters an entry-point keyword at the beginning of a <code>local</code> statment (e.g. <code>local terra foo() end</code>). Similar to <code>statement</code> this method can also return a list of names (e.g. <code>{"a","b"}</code>). However, in this case, these names will be defined as local variables <code>local a, b = constructor(...)</code></p>

<h3 id="tokens">Tokens</h3>

<p>The methods in the language are given an interface <code>lexer</code> to Terra <em>lexer</em>, which can be used to examine the stream of <em>tokens</em>, and to report errors.  A <em>token</em> is a Lua table with fields:</p>

<hr />

<pre><code>token.type
</code></pre>

<p>The <em>token type</em>. For keywords and operators this is just a string (e.g. <code>"and"</code>, or <code>"+"</code>). The values <code>lexer.name</code>, <code>lexer.number</code>, <code>lexer.string</code> indicate the token is respectively an identifier (e.g. <code>myvar</code>), a number (e.g. 3), or a string (e.g. <code>"my string"</code>). The type <code>lexer.eof</code> indicates the end of the token stream. </p>

<hr />

<pre><code>token.value
</code></pre>

<p>For names, strings, and numbers this is the specific value (e.g. <code>3.3</code>). Numbers are represented as Lua numbers when they would fit (floating point or 32-bit integers) and ‘[u]int64_t’ cdata types for 64-bit integers.</p>

<hr />

<pre><code>token.valuetype
</code></pre>

<p>For numbers this is the Terra type of the literal parsed. <code>3</code> will have type <code>int</code>, <code>3.3</code> is <code>double</code>, <code>3.f</code> is <code>float</code>, <code>3ULL</code> is <code>uint64</code>, <code>3LL</code> is <code>int64</code>, and <code>3U</code> is <code>uint</code>.</p>

<hr />

<pre><code>token.linenumber
</code></pre>

<p>The linenumber on which this token occurred (not available for lookahead tokens).</p>

<hr />

<pre><code>token.offset
</code></pre>

<p>The offset in characters from the beginning of the file where this token occurred (not available for lookahead tokens).</p>

<h3 id="lexer">Lexer</h3>

<p>The <code>lexer</code> object provides the following methods fields and methods. The <code>lexer</code> itself is only valid during parsing. For instance, it should <em>not</em> be called from the constructor function.</p>

<hr />

<pre><code>lexer:cur()
</code></pre>

<p>Returns the current <em>token</em>. Does not modify the position.</p>

<hr />

<pre><code>lexer:lookahead()
</code></pre>

<p>Returns the <em>token</em> following the current token. Does not modify the position. Only 1 token of lookahead is allowed to keep the implementation simple.</p>

<hr />

<pre><code>lexer:matches(tokentype)
</code></pre>

<p>shorthand for <code>lexer:cur().type == tokentype</code></p>

<hr />

<pre><code>lexer:lookaheadmatches(tokentype)
</code></pre>

<p>Shorthand for <code>lexer:lookahead().type == tokentype</code></p>

<hr />

<pre><code>lexer:next()
</code></pre>

<p>Returns the current token, and advances to the next token.</p>

<hr />

<pre><code>lexer:nextif(tokentype)
</code></pre>

<p>If <code>tokentype</code> matches the <code>type</code> of the current token, it returns the token and advances the lexer. Otherwise, it returns <code>false</code> and does not advance the lexer. This function is useful when you want to try to parse many alternatives.</p>

<hr />

<pre><code>lexer:expect(tokentype)
</code></pre>

<p>If <code>tokentype</code> matches the type of the current token, it returns the token and advances the lexer. Otherwise, it stops parsing an emits an error. It is useful to use when you know what token should appear.</p>

<hr />

<pre><code>lexer:expectmatch(tokentype,openingtokentype,linenumber)
</code></pre>

<p>Same as <code>expect</code> but provides better error reporting for matched tokens. For instance, to parse the closing brace <code>}</code> of a list you can call <code>lexer:expectmatch('}','{',lineno)</code>. It will report a mismatched bracket as well as the opening and closing lines.</p>

<hr />

<pre><code>lexer.source
</code></pre>

<p>A string containing the filename, or identifier for the stream (useful for future error reporting)</p>

<hr />

<pre><code>lexer:error(msg)
</code></pre>

<p>Report a parse error and give up. <code>msg</code> is a string. Does not return.</p>

<hr />

<pre><code>lexer:errorexpected(msg)
</code></pre>

<p>Report that the string <code>msg</code> was expected but did not appear. Does not return.</p>

<hr />

<pre><code>lexer:ref(name)
</code></pre>

<p><code>name</code> is a string. Indicates to the Terra parser that your language may refer to the Lua variable <code>name</code>. This function must be called for any free identifiers that you are interested in looking up. Otherwise, the identifier may not appear in the lexical environment passed to your <em>constructor</em> functions. It is safe (though less efficient) to call it for identifiers that it may not reference.</p>

<hr />

<pre><code>lexer:luaexpr()
</code></pre>

<p>Parses a single Lua expression from the token stream. This can be used to switch back into the Lua language for expressions in your language. For instance, Terra uses this to parse its types (which are just Lua expressions): <code>var a : aluaexpression(4) = 3</code>. It returns a function <code>function(lexicalenv)</code> that takes a table of the current lexical scope (such as the one return from <code>environment_function</code> in the constructor) and returns the value of the expression evaluated in that scope. This function is not intended to be used to parse a Lua expression into an AST. Currently, parsing a Lua expression into an AST requires you to writing the parser yourself. In the future we plan to add a library which will let you pick and choose pieces of Lua/Terra’s grammar to use in your language.</p>

<h2 id="future-extensions">Future Extensions</h2>

<ul>
  <li>
    <p>The Pratt parsing library will be extended to support composing multiple languages together</p>
  </li>
  <li>
    <p>We will use the composable Pratt parsing library to implement a library of common statements and expressions from Lua/Terra that will allow the user to pick and choose which statements to include, making it easy to get started with a language.</p>
  </li>
</ul>


      </section>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    <script src="javascripts/prism.js"></script>
  </body>
</html>
